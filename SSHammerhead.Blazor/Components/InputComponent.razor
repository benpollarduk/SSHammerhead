@using NetAF.Logic.Modes

<div style="display: flex; align-items: center; @(!showInput && !showCommandPicker ? "display: none;" : "")">
    <span style="font-size: 11px; margin-right: 10px; margin-left: 5px;">Input mode: </span>
    <input type="radio" value="@InputMode.Text"checked="@(selectedInputMode.Equals(InputMode.Text))" @onchange="OnChange" />
    <span style="font-size: 11px; margin-right: 10px; margin-left: 5px;">@InputMode.Text </span>
    <input type="radio" value="@InputMode.Pick" checked="@(selectedInputMode.Equals(InputMode.Pick))" @onchange="OnChange" />
    <span style="font-size: 11px;">@InputMode.Pick</span>
</div>

@if (!showInput && showCommandPicker)
{
    <br />
}

<div style="@(!showInput ? "display: none;" : "")">
    <input type="text" style="width: @(contentWidth); height:35px; font-size: 16px;" @ref="textInput" @bind="text" @onkeyup="HandleInput" />
</div>

@if (showInput && showCommandPicker)
{
    <br/>
}

<div style="width: @(contentWidth); @(!showCommandPicker ? "display: none;" : "")">
    <CommandPickerComponent @ref="commandPickerComponent" />
</div>

<div style="@(!showAcknowledge ? "display: none;" : "")">
    <button class="btn btn-primary" style="width: @(contentWidth); height:35px; font-size: 16px;" @ref="acknowledgeButton" @onclick="Acknowledge">OK</button>
</div>

@code {
    private string text = string.Empty;
    private bool showInput = true;
    private bool showAcknowledge = true;
    private bool showCommandPicker = true;
    private ElementReference acknowledgeButton;
    private ElementReference textInput;
    private HtmlAdapter? htmlAdapter;
    private CommandPickerComponent? commandPickerComponent;
    private string contentWidth = "530px";
    private InputMode selectedInputMode = InputMode.Pick;
    private enum InputMode { Text, Pick };

    private void Acknowledge()
    {
        GameExecutor.Update();
    }

    private void HandleInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(text))
        {
            GameExecutor.Update(text);
            text = string.Empty;
        }
    }

    private async void UpdateInputMode()
    {
        showInput = (htmlAdapter?.Game?.Mode?.Type == GameModeType.Interactive) && (selectedInputMode == InputMode.Text);
        showCommandPicker = (htmlAdapter?.Game?.Mode?.Type == GameModeType.Interactive) && (selectedInputMode == InputMode.Pick);
        showAcknowledge = htmlAdapter?.Game?.Mode?.Type == GameModeType.Information;

        await InvokeAsync(StateHasChanged);
    }

    public async void Update()
    {
        UpdateInputMode();
        commandPickerComponent?.Clear();

        await InvokeAsync(StateHasChanged);

        if (htmlAdapter?.Game?.Mode?.Type == GameModeType.Interactive)
        {
            var commands = htmlAdapter?.Game?.GetContextualCommands()?.ToArray() ?? [];
            commandPickerComponent?.Update(commands);
        }

        if (showInput && textInput.Context != null)
            await textInput.FocusAsync();

        if (showAcknowledge && acknowledgeButton.Context != null)
            await acknowledgeButton.FocusAsync();
    }

    public void SetAdapter(HtmlAdapter adapter)
    {
        htmlAdapter = adapter;
        commandPickerComponent?.SetAdapter(adapter);
    }

    private void OnChange(ChangeEventArgs args)
    {
        if (Enum.TryParse<InputMode>(args?.Value?.ToString() ?? string.Empty, out var mode))
        {
            selectedInputMode = mode;
            UpdateInputMode();
        }
    }
}
